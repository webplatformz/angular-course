<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <title>Intro</title>

    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/gh/Zuehlke/zuehlke-reveal-package@12d464d3ae3c5bbe96af93ece05bd5ebeaabefbe/release/index.css">
    <link rel="icon" href="./assets/zuehlke-logo.jpg">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section class="title-slide">
            <h1>Advanced Angular</h1>
            <h2>Silas FÃ¼glistaler, Marco Romanutti & Lucas SchnÃ¼riger</h2>
            <h3>Use Angular the Angular way</h3>
        </section>

        <section>
            <section class="subtitle-slide">
                <h1>Dependency Injection & Services</h1>
            </section>
        </section>

        <section>
            <section class="subtitle-slide">
                <h1>Forms</h1>
            </section>
        </section>

        <section>
            <section class="subtitle-slide">
                <h1>Lifecycle & Change Detection</h1>
            </section>

            <section>
                <h2>Component Lifecycle</h2>
                <p>Components have a lifecycle managed by Angular, which offers lifecycle hook interfaces.</p>
                <p>By implementing those, we can hook into different steps of the lifecycle.</p>
            </section>

            <section>
                <h2>Full Lifecycle</h2>
                <img src="../img/2-angular-lifecycle.svg"/>
                <aside class="notes">
                    <ul>
                        <li>ngOnChanges is initially called only if there are inputs</li>
                        <li>ngDoCheck is called on every change detection run, allowing implement a custom change detection, in cases where onChanges doesn't catch changes</li>
                        <li>content hooks are about
                            <i>projected content</i> (ng-content), view are about the template of the component and its children
                        </li>
                        <li>ngAfterView... hooks are called <i>after</i> the child component views are created</li>
                    </ul>
                </aside>
            </section>

            <section>
                <h1>ðŸ¤¯</h1>
            </section>

            <section>
                <h2>Important Hooks</h2>
                <p>Most of these hooks are only relevant in rare edge cases. The most important ones are:</p>
                <ul>
                    <li class="fragment"><b>ngOnInit:</b> initialize the component</li>
                    <li class="fragment">
                        <b>ngOnDestroy:</b> for cleanup, called immediately before component is destroyed
                    </li>
                    <li class="fragment"><b>ngOnChanges:</b> when data-bound input properties change</li>
                </ul>
            </section>

            <section>
                <h2>ngOnInit</h2>
                <pre><code class="hljs ts" contenteditable data-trim>
                   @Component({selector: 'my-cmp', template: `...`})
                    class MyComponent implements OnInit {
                      public data$: Observable&lt;Data&gt;;

                      ngOnInit() {
                        this.data$ = this.http.get('/api');
                        // ...
                      }
                    }
                </code></pre>
            </section>

            <section>
                <h2>Constructor vs. ngOnInit</h2>
                <ul>
                    <li>constructor is for dependency injection</li>
                    <li>JS handles the constructor, Angular handles ngOnInit</li>
                    <li>input properties are only set <u>after</u> the constructor</li>
                </ul>
                <div class="tip fragment">an empty constructor is a good constructor</div>
            </section>

            <section>
                <h2>ngOnDestroy</h2>
                <pre><code class="hljs ts" contenteditable data-trim>
                    @Component({selector: 'my-cmp', template: `...`})
                    class MyComponent implements OnDestroy {
                      private subscription: Subscription;

                      ngOnDestroy() {
                        this.subscription.unsubscribe();
                        // ...
                      }
                    }
                </code></pre>
                <div class="tip fragment">clean up after yourself!</div>
            </section>

            <section>
                <h2>ngOnChanges</h2>
                <pre><code class="hljs ts" contenteditable data-trim>
                    @Component({selector: 'my-cmp', template: `...`})
                    class MyComponent implements OnChanges {
                      @Input() prop: number = 0;

                      ngOnChanges({prop}: SimpleChanges) {
                        if (prop.previousValue !== prop.currentValue) {
                          // ...
                        }
                      }
                    }
                </code></pre>
            </section>

            <section>
                <h2>Change Detection</h2>
                <p>Angular detects when component data changes, calls <span class="code">ngOnChanges</span> and re-renders the view.</p>
                <p>It does that by overriding/patching most browser APIs such as <span class="code">addEventListener</span> to trigger the the change detection.</p>
                <p>This patching is handled by the <strong class="hl">Zone.js</strong> library, which provides a persistent zone across async tasks and events.</p>
                <aside class="notes">This is why "Zone.js" appears in error stacktraces. It's the bridge between Angular and the browser API.</aside>
            </section>

            <section>
                <h2>Default behavior</h2>
                <p>Each component has an associated change detector, which is created at app startup time.</p>
                <p>By default each <strong class="hl">template expression</strong> is checked, whether the current values in it differ from the previous ones.</p>
            </section>

            <section>
                <h2>Alternative CD Strategy</h2>
                <p>We can set a different strategy on component-level called <span
                        class="code">OnPush</span>, which will check in these cases:</p>
                <ul>
                    <li class="fragment">when any of the component's input properties change (i.e. their references)</li>
                    <li class="fragment">when the component fires an event</li>
                    <li class="fragment">when an Observable fires an event</li>
                </ul>
            </section>

            <section>
                <h2>Use OnPush</h2>
                <pre><code class="hljs ts" contenteditable data-trim data-noescape>
                    @Component({
                        selector: 'todo-list', template: '...',
                        <b>changeDetection: ChangeDetectionStrategy.OnPush</b>,
                    })
                    export class TodoList {
                        addTodoMutating() { // doesn't trigger a re-render!
                            this.todos.push(new Todo("TODO 4", false, "John"));
                        }

                        addTodoImmutable() { // works, assigns a new object
                            const newTodo = new Todo("TODO 4", false, "John");
                            this.todos = [...this.todos, newTodo];
                        }
                    }
                </code></pre>
            </section>

            <section>
                <h2>OnPush & Immutability</h2>
                <p><span class="code">OnPush</span> works well in combination with strict immutability.</p>
                <p>If you build your application using immutable objects only, you can use <span class="code">OnPush</span> everywhere.</p>
                <p>Otherwise it's easy to create change detection bugs with <span class="code">OnPush</span>.</p>
                <div class="fragment tip">Use a library like Immutable.js or Immer to ensure immutability!</div>
            </section>

            <section>
                <h2>Default vs. OnPush</h2>
                <div class="comparison">
                    <div>
                        <img src="../img/2-cd-cycle.gif" alt="Default Change Detection Cycle">
                    </div>
                    <div>
                        <img src="../img/2-cd-on-push-cycle.gif" alt="OnPush Change Detection Cycle">
                    </div>
                </div>
                <small>Source: <a href="https://mokkapps.de/blog/the-last-guide-for-angular-change-detection-you-will-ever-need/">Mokkapps</a></small>
            </section>

            <section>
                <h2>Performance</h2>
                <p>Using <span class="code">OnPush</span> <em>can</em> improve the runtime performance.</p>
                <p>But be aware of its implications.</p>
            </section>

            <section>
                <h2>Change Detection Loops</h2>
                <img src="../img/2-cd-expression-changed-error.png"
                     alt="Screenshot of browser console containing an error 'Expression changed after it has been checked'">
                <div class="fragment">
                    <p>Angular enforces a <strong class="hl">uni-direction data flow</strong>. Child components are not allowed to change data in the parent (use events).</p>
                    <p>Updating the view doesn't trigger further changes that trigger further updates to the view: no loops.</p>
                </div>
            </section>

            <section>
                <h2>Manual Change Detection</h2>
                <p>It's possible to disable the automatic CD with the <span class="code">ChangeDetectorRef</span>:</p>
                <pre><code class="hljs ts" contenteditable data-trim>
                    constructor(private ref: ChangeDetectorRef) {
                        ref.detach(); // disable automatic CD for subtree
                        setInterval(() => { // run CD every 5 sec
                          this.ref.detectChanges();
                        }, 5000);
                    }
                </code></pre>
                <p class="fragment">This is likely just a way to treat the symptoms rather than fix the problem underneath.</p>
                <div class="fragment tip">Use with care, know what you're doing!</div>
            </section>
        </section>

        <section>
            <section class="subtitle-slide">
                <h1>Guards & Resolvers</h1>
            </section>
        </section>

        <section>
            <section class="subtitle-slide">
                <h1>Interceptors</h1>
            </section>

            <section>
                <h2>HTTP Communication</h2>
                <p>Angular provides a client HTTP API with the <span class="code">HttpClient</span> service.</p>
                <p>Making HTTP requests through that offers multiple helpful features, among them: <strong class="hl">interception</strong>.</p>
            </section>

            <section>
                <h2>Interception</h2>
                <p>Interception allows you to <strong class="hl">inspect and transform</strong> HTTP requests and responses.</p>
                <img src="../img/2-interceptor-overview.png" alt="Diagram showing Interceptor between Angular Application and Sever, having HTTP requests and responses going through it">
                <p>Multiple interceptors can form a chain of request/response handlers, that are applied to all HTTP communication.</p>
            </section>

            <section>
                <h2>Write an Interceptor</h2>
                <pre><code class="hljs ts" contenteditable data-trim>
                    import { Injectable } from '@angular/core';
                    import {
                        HttpEvent, HttpInterceptor, HttpHandler, HttpRequest
                    } from '@angular/common/http';
                    import { Observable } from 'rxjs';

                    @Injectable()
                    export class NoopInterceptor implements HttpInterceptor {
                        intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler):
                            Observable&lt;HttpEvent&lt;any&gt;&gt; {
                            // pass untouched request to next handler
                            return next.handle(req);
                        }
                    }
                </code></pre>
            </section>

            <section>
                <h2>Request / Response</h2>
                <p>The <span class="code">req</span> parameter is the HTTP request.</p>
                <p>The <span class="code">next</span> object represents the next interceptor in the chain, or the HttpBackend handler at the end of the chain.</p>
                <p>The return value of the <span class="code">handle</span> method is the HTTP response.</p>
                <p>This way we can handle both directions inside an interceptor.</p>
            </section>

            <section>
                <h2>Provide Interceptors</h2>
                <p>Interceptors are handled by Angular's dependency injection system.</p>
                <p>Add them to the providers in your <span class="code">app.module.ts</span>:</p>
                <pre><code class="hljs ts" contenteditable data-trim>
                    {
                        provide: HTTP_INTERCEPTORS, // DI token
                        useClass: NoopInterceptor,  // our interceptor
                        multi: true      // allow multiple interceptors
                    }
                </code></pre>
            </section>

            <section>
                <h2>Interceptor Order</h2>
                <p>The order in which interceptors are provided is relevant. They're getting applied Â«from the outside inÂ»:</p>
                <div class="comparison">
                    <div>
                        <pre style="margin: 0;"><code class="hljs ts" contenteditable data-trim data-noescape>
                            providers: [
                              {
                                provide: HTTP_INTERCEPTORS,
                                useClass: <b>AuthInterceptor</b>,
                                multi: true
                              },
                              {
                                provide: HTTP_INTERCEPTORS,
                                useClass: <b>LoggingInterceptor</b>,
                                multi: true
                              },
                            ]
                        </code></pre>
                    </div>
                    <div style="text-align: center;">
                        <img src="../img/2-interceptor-order.svg" alt="Order of Interceptors from the HttpClient to AuthInterceptor to LoggingInterceptor to HttpBackend and then the server. The response goes the other way back.">
                    </div>
                </div>
            </section>

            <section>
                <h2>Use of Interceptors</h2>
                <ul>
                    <li>Logging</li>
                    <li>Setting headers for: authentication, XSRF â€¦</li>
                    <li>Custom JSON parsing</li>
                    <li>Caching</li>
                    <li>Track Request Progress / Loading State</li>
                    <li>Global Error Handling</li>
                </ul>
            </section>

            <section class="exercise">
                <div>
                    <span class="title">Exercise</span>
                    <span class="description">Add a logging interceptor</span>
                </div>
            </section>

            <section>
                <h2>Interceptor Exercise</h2>
                <p>Add an interceptor to the application that logs the following type of message for each request to the console:</p>
                <p><span class="code">GET request to api/heroes resulted in a OK (200) response after 502 ms</span></p>
            </section>
        </section>

        <section>
            <section class="subtitle-slide">
                <h1>Testing</h1>
            </section>
        </section>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/gh/Zuehlke/zuehlke-reveal-package@12d464d3ae3c5bbe96af93ece05bd5ebeaabefbe/release/index.js"></script>
<script>
	setupZuehlkeRevealPresentation();
</script>
</body>
</html>
